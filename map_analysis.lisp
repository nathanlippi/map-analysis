;; Exploring a faster way to do analysis of maps 
;; Want to make a simple implementation first, then test out different
;; algorithms
;;

;; (load "/home/nathan/Dropbox/projects/map_analysis/map_analysis.lisp")
;; (analyze-map-brute (generate-map-random 10 10) 3)
;;
;; The below takes below .14x seconds on my machine
;; (benchmark-analyze-map 'analyze-map-brute :map-size 200 :radius 2)
;;
;; Using a macro to slightly simplify syntax:
;; (benchmark-map analyze-map-brute :map-size 10 :radius 2)
;;
;; This needs to be switched over to doing ARRAYS not
;; lists... probably much more efficient...
;;
;; Next up:
;; Stretch the map every x/y pixels when displaying

(dolist (x '(:hunchentoot :parenscript))
  (asdf:oos 'asdf:load-op x))

(ql:quickload "cl-json")

(defpackage "MAP-ANALYSIS"
  (:use "COMMON-LISP" "HUNCHENTOOT" "PARENSCRIPT"))
(in-package "MAP-ANALYSIS")

(defun slice (list start last) (subseq list start (1+ last)))

;; These two fns are from:
;; http://stackoverflow.com/questions/9549568/common-lisp-convert-between-lists-and-arrays
(defun list-to-2d-array (list)
  (make-array (list (length list)
                    (length (first list)))
              :initial-contents list))

(defun 2d-array-to-list (array)
  (loop for i below (array-dimension array 0)
        collect (loop for j below (array-dimension array 1)
                      collect (aref array i j))))

;; http://norvig.com/paip/simple.lisp
(defun random-elt (choices)
  (elt choices (random (length choices))))

(defun range (start end) (loop for i from start to end collect i))

;; Can use aref here
;; Would this be more efficient with big lists?
(defun get-point (map x y) (nth x (nth y map)))
(defun set-point (map x y val) (setf (nth x (nth y map)) val) map)

(defun rotate (list-of-lists)
  (apply #'mapcar #'list list-of-lists))

(defun generate-map-random (map-x map-y)
  (loop for i from 1 to map-y collect
    (loop for j from 1 to map-x collect (random 100))))

(defun generate-map-flat (map-x map-y &key (height 50))
    (2d-array-to-list (make-array (list map-y map-x) :initial-element height)))

;; Make sure that any transformation cannot go outside 0 - 100?
(defun transform-map-roughen (map &key (max-variation 2))
  (mapcar #'(lambda(map-row) (mapcar 
      #'(lambda(x) (let 
          ((val (+ (random-in-range max-variation) x))) (point-in-range val)))
    map-row)) map))

(defun transform-map-wave (map &key (max-slope 10) (max-variation 2))
  (let ((slope (random-in-range max-slope)) (variation 0))
    (mapcar #'(lambda(map-row) 
      (setf variation (random-in-range max-variation))
      (setf slope (point-in-range (+ slope variation) :max max-slope :min (*- max-slope)))
      (transform-row-shift map-row slope)) map)))

(defun transform-map-wave-vertical (map &key (max-slope 10) (max-variation 2))
  (rotate 
    (transform-map-wave (rotate map) :max-slope max-slope :max-variation max-variation)))

(defun transform-row-shift (row vector)
  (mapcar #'(lambda(cell) (point-in-range (+ cell vector))) row))

(defun point-in-range (pt &key (min 0) (max 100))
  (if (> pt min) (if (<= pt max) pt max) min))

(defun *- (num) (* -1 num))
;; Pass it one num ... 10 would imply a range from -10 to 10
(defun random-in-range (num) (random-elt (range (*- num) num)))

;; Will currently get surrounding square, not circle
(defun get-surrounding-points (map x y radius)
  (let ((x-min (- x radius)) (x-max (+ x radius))(y-min (- y radius)) (y-max (+ y radius)))
    (loop for n from y-min to y-max collect (slice (nth n map) x-min x-max))))

;; Assumes a square subsection of a map
;; Should get average of all the parts and then relate them to center 
;; in terms of a ratio
(defun get-center-relation (sub-map)
  (let* ((map-len (length sub-map)) (ctr-pt (/ (1- map-len) 2))
         (ctr-val (get-point sub-map ctr-pt ctr-pt)) 
         (num-pts (1- (* map-len map-len))))
    (/ ctr-val (/ (- (loop for list in sub-map sum (apply '+ list)) ctr-val) num-pts))))

;; Should return a 2d data structure that is (- map-x radius) by (- map-y radius)
;; Is passed a (rectangular) map structure generated by generate-map-random 
(defun analyze-map-brute (map radius)
  ;; For each point on the map that has enough data
  (let ((min radius) (y-max (- (length map) (1+ radius))) 
        (x-max (- (length (nth 0 map)) (1+ radius))))
    (loop for y from min to y-max collect
      (loop for x from min to x-max collect 
        (get-center-relation (get-surrounding-points map x y radius))))))

(defun benchmark-analyze-map (analyze-fn map-size radius)
  (let ((start-time (get-internal-real-time)))
    (funcall analyze-fn (generate-map-random map-size map-size) radius)
      (concatenate 'string "Time elapsed: " 
        (prin1-to-string (- (get-internal-real-time) start-time)))))

;; Macro to get rid of the quote!
(defmacro benchmark-map (analyze-fn &key (map-size 100) (radius 3))
  `(benchmark-analyze-map ',analyze-fn ,map-size ,radius))

(hunchentoot:define-easy-handler (map-random :uri "/maprandom") (size)
  (setf (hunchentoot:content-type*) "application/json")
  (let* ((sz (parse-integer size)) (map (generate-map-random sz sz)))
    (json:encode-json-to-string map)))

(hunchentoot:define-easy-handler (map-animate :uri "/mapanimate") (size)
  (setf (hunchentoot:content-type*) "application/json")
  (let ((sz (parse-integer size)))
    (json:encode-json-to-string
      (transform-animate (generate-map-flat sz sz) 
                         (transform-map-wave :max-variation 5 :max-slope 20)
                         (transform-map-wave-vertical :max-variation 5 :max-slope 10)
                         (transform-map-roughen :max-variation 5)
                         (transform-map-roughen :max-variation 10)
                         (transform-map-roughen :max-variation 10)))))

;; What I want for the macro:
;; (transform-animate (generate-map-random 5 5) 
;;                    (transform-map-roughen :max-variation 1)
;;                    (transform-map-roughen :max-variation 1))
;;

(defmacro transform-animate (map-generate-fn &rest map-transform-fns)
  `(let ((map-list (list ,map-generate-fn)))
    ,@(loop for map-transform-fn in map-transform-fns collect
       `(setf map-list (cons 
          ,(insert-after map-transform-fn 0 '(car map-list)) map-list)))
    (reverse map-list)))

(defun insert-after (lst index newelt)
  (push newelt (cdr (nthcdr index lst))) lst)

;; Make a macro where one you pass it a list of fns...  The first fn
;; generates the map, then the subsequent fns progressively transform it}
(hunchentoot:start (make-instance 'hunchentoot:easy-acceptor 
                      :port 8082 
                      :document-root #p"/home/nathan/Dropbox/projects/map_analysis/www/"))

