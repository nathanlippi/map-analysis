;; Exploring a faster way to do analysis of maps 
;; Want to make a simple implementation first, then test out different
;; algorithms
;;

;; (load "/home/nathan/Dropbox/projects/map_analysis/map_analysis.lisp")
;; (analyze-map-brute (generate-map-random 10 10) 3)
;;
;; The below takes below .14x seconds on my machine
;; (benchmark-analyze-map 'analyze-map-brute :map-size 200 :radius 2)
;;
;; Using a macro to slightly simplify syntax:
;; (benchmark-map analyze-map-brute :map-size 10 :radius 2)
;;

(dolist (x '(:hunchentoot :parenscript))
  (asdf:oos 'asdf:load-op x))

(ql:quickload "cl-json")

(defpackage "MAP-ANALYSIS"
  (:use "COMMON-LISP" "HUNCHENTOOT" "PARENSCRIPT"))
(in-package "MAP-ANALYSIS")

(defun slice (list start last) (subseq list start (1+ last)))
(defun get-point (map x y) (nth x (nth y map)))

(defun generate-map-random (map-x map-y)
  (loop for i from 1 to map-y collect
    (loop for j from 1 to map-x collect (random 100))))

;; Will currently get surrounding square, not circle
(defun get-surrounding-points (map x y radius)
  (let ((x-min (- x radius)) (x-max (+ x radius))(y-min (- y radius)) (y-max (+ y radius)))
    (loop for n from y-min to y-max collect (slice (nth n map) x-min x-max))))

;; Assumes a square subsection of a map
;; Should get average of all the parts and then relate them to center 
;; in terms of a ratio
(defun get-center-relation (sub-map)
  (let* ((map-len (length sub-map)) (ctr-pt (/ (1- map-len) 2))
         (ctr-val (get-point sub-map ctr-pt ctr-pt)) 
         (num-pts (1- (* map-len map-len))))
    (/ ctr-val (/ (- (loop for list in sub-map sum (apply '+ list)) ctr-val) num-pts))))

;; Should return a 2d data structure that is (- map-x radius) by (- map-y radius)
;; Is passed a (rectangular) map structure generated by generate-map-random 
(defun analyze-map-brute (map radius)
  ;; For each point on the map that has enough data
  (let ((min radius) (y-max (- (length map) (1+ radius))) 
        (x-max (- (length (nth 0 map)) (1+ radius))))
    (loop for y from min to y-max collect
      (loop for x from min to x-max collect 
        (get-center-relation (get-surrounding-points map x y radius))))))

(defun benchmark-analyze-map (analyze-fn map-size radius)
  (let ((start-time (get-internal-real-time)))
    (funcall analyze-fn (generate-map-random map-size map-size) radius)
      (concatenate 'string "Time elapsed: " 
        (prin1-to-string (- (get-internal-real-time) start-time)))))

;; Macro to get rid of the quote!
(defmacro benchmark-map (analyze-fn &key (map-size 100) (radius 3))
  `(benchmark-analyze-map ',analyze-fn ,map-size ,radius))

(hunchentoot:define-easy-handler (map-random :uri "/maprandom") (size)
  (setf (hunchentoot:content-type*) "application/json")
  (let* ((sz (parse-integer size)) (map (generate-map-random sz sz)))
    (json:encode-json-to-string map)))

(hunchentoot:start (make-instance 'hunchentoot:easy-acceptor 
                      :port 8082 
                      :document-root #p"/home/nathan/Dropbox/projects/map_analysis/www/"))
